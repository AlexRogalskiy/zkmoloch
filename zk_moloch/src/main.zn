//!
//! The 'zk_moloch' contract entry.
//!

// The TokenAddress enumeration lists the token address-like identifiers
// from the Rinkeby zkSync network. Addresses of tokens on the Rinkeby network
// should not change and may be taken from here for further usage.
//
// source: https://zinc.zksync.io/07-smart-contracts/02-minimal-example.html#project-initialization

use std::collections::MTreeMap;

mod constants;
use self::constants::N;
use self::constants::AMOUNT_10_18;

type Address = u160;
type Balance = u248;


contract ZkMoloch {
    // GLOBAL CONSTANTS
    pub periodDuration: u248;       // default = 17280 = 4.8 hours in seconds (5 periods per day)
    pub votingPeriodLength: u248;   // default = 35 periods (7 days)
    pub gracePeriodLength: u248;    // default = 35 periods (7 days)
    pub proposalDeposit: u248;      // default = 10 ETH (~$1,000 worth of ETH at contract deployment)
    pub dilutionBound: u248;        // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit
    pub processingReward: u248;     // default = 0.1 - amount of ETH to give to whoever processes a proposal
    // pub summoningTime: u64;      // needed to determine the current period

    pub depositToken: Address;      // deposit token contract reference; default = wETH
    pub approvedTokens: [Address; N];
    pub tokenWhitelist: MTreeMap<Address, bool>;

    // HARD-CODED LIMITS
    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations
    // with periods or shares, yet big enough to not limit reasonable use cases.
    const MAX_VOTING_PERIOD_LENGTH: u248 = AMOUNT_10_18;        // maximum length of voting period
    const MAX_GRACE_PERIOD_LENGTH: u248 = AMOUNT_10_18;         // maximum length of grace period
    const MAX_DILUTION_BOUND: u248 = AMOUNT_10_18;              // maximum dilution bound
    const MAX_NUMBER_OF_SHARES_AND_LOOT: u248 = AMOUNT_10_18;   // maximum number of shares that can be minted

    pub fn new(_summoner: Address,
               _approvedTokens: [Address; N],
               _periodDuration: u248,
               _votingPeriodLength: u248,
               _gracePeriodLength: u248,
               _proposalDeposit: u248,
               _dilutionBound: u248,
               _processingReward: u248) -> Self {

        require(_summoner != 0, "_summoner cannot be 0");
        require(_periodDuration > 0, "_periodDuration cannot be 0");
        require(_votingPeriodLength > 0, "_votingPeriodLength cannot be 0");
        require(_votingPeriodLength <= Self::MAX_VOTING_PERIOD_LENGTH, "_votingPeriodLength exceeds limit");
        require(_gracePeriodLength <= Self::MAX_GRACE_PERIOD_LENGTH, "_gracePeriodLength exceeds limit");
        require(_dilutionBound > 0, "_dilutionBound cannot be 0");
        require(_dilutionBound <= Self::MAX_DILUTION_BOUND, "_dilutionBound exceeds limit");
        // require(_approvedTokens.length > 0, "need at least one approved token");
        require(_proposalDeposit >= _processingReward, "_proposalDeposit cannot be smaller than _processingReward");

        let mut obj: Self = Self {
            periodDuration: _periodDuration,
            votingPeriodLength: _votingPeriodLength,
            gracePeriodLength: _gracePeriodLength,
            proposalDeposit: _proposalDeposit,
            dilutionBound: _dilutionBound,
            processingReward: _processingReward,
            // summoningTime: now,
            depositToken: _approvedTokens[0],
            approvedTokens: _approvedTokens,
            tokenWhitelist: MTreeMap,
        };

/*
        // the code below runs into:
        // "thread '<unnamed>' panicked at 'Value always exists'"
        // https://gist.github.com/oberstet/ffe1ebd78d587e349b93c092c902819f

        for i in 0..N {
            if (_approvedTokens[i] != 0) {
                require(!obj.tokenWhitelist.get(_approvedTokens[i]), "duplicate approved token");
            }
        }
*/
        obj
    }
}
